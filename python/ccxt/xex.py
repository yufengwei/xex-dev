# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ExchangeError


class xex (Exchange):

    def describe(self):
        return self.deep_extend(super(xex, self).describe(), {
            'id': 'xex',
            'name': 'XEX',
            'countries': ['JP'],
            'comment': 'Xex API',
            'has': {
                'fetchTicker': True,
                'fetchOHLCV': True,
                'fetchOrderBook': True,
                'fetchTrades': True,
                'fetchMyTrades': True,
                'fetchOrderBooks': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'createOrder': True,
                'cancelOrder': True,
                'fetchBalance': True,
            },
            'timeframes': {
                '1m': '1MIN',
                '5m': '5MIN',
                '15m': '15MIN',
                '30m': '30MIN',
                '1h': '1H',
                '2h': '2H',
                '4h': '4H',
                '6h': '6H',
                '12h': '12H',
                '1d': 'D',
                '2d': '2D',
                '1w': 'W',
                'month': 'MONTH',
            },
            'urls': {
                'logo': 'https://www.crossexchange.io/images/logo_icon.png',
                'api': 'https://api.xex-dev.com',
                'www': 'https://www.crossexchange.io/cross/home',
                'doc': 'https://support.crossexchange.io/hc/en-us/categories/360001030591?flash_digest=4496738595f09128fc199486ac8f0fcee028b0ab',
            },
            'api': {
                'public': {
                    'get': [
                        'GET/v1/api/ticker',
                        'GET/v1/api/kline',
                        'GET/v1/api/depth',
                        'GET/v1/api/trades',
                    ],
                },
                'private': {
                    'get': [
                        'GET/v1/api/orderdetail',
                        'GET/v1/api/auth/wallet',
                        'GET/v1/api/mineLimit',
                    ],
                       
                    'post': [
                        'POST/v1/api/trades',
                        'POST/v1/api/orders',
                        'POST/v1/api/auth/orders',
                        'POST/v1/api/cancelOrder',
                        'POST/v1/api/placeOrder',
                        'POST/api/v1/make/leverOrder',
                        'POST/api/v1/cancle/leverOrder',
                        'POST/api/v1/leverage/change/order',
                        'POST/api/v1/leverage/charge',
                        'POST/api/v1/show/open/leverOrder',
                    ],
                },
            },
        })

    def fetch_markets(self, params={}):
    	response = self.fetch('https://web.crossexchange.io/bb/symbol/all?leverageType=0')
    	pairs = response['data']['bbPairList']
    	ret = []
    	for p in range(0, len(pairs)):
            value = pairs[p]
            symbol = value['name']
            parts = symbol.split("_")
            base = parts[1]
            quote = parts[0]
            ret.append({
                'id': symbol,
                'symbol': symbol,
                'base': base,
                'quote': quote,
            })

        return ret

    def fetch_balance(self, params={}):
        response = self.privateGetGETV1ApiAuthWallet()
        result = {'info': response}
        balance = response['data']
        free = balance['free']
        freezed = balance['freezed']
        coins = list(free.keys())
        for i in range(0, len(coins)):
            currency = coins[i]
            account = self.account()
            account['free'] = float(free[currency])
            account['used'] = float(freezed[currency])
            account['total'] = self.sum(account['free'], account['used'])
            result[currency] = account
        return self.parse_balance(result)

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        response = self.publicGetGETV1ApiDepth(self.extend({
            'pair': self.market_id(symbol),
        }, params))
        return self.parse_order_book(response['data'], response['data']['timestamp'])

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        response = self.publicGetGETV1ApiTicker(self.extend({
            'pair': self.market_id(symbol),
        }, params))
        ticker = response['data']
        last = self.safe_float(ticker, 'last')
        return {
            'symbol': symbol,
            'timestamp': ticker['timestamp'],
            'datetime': None,
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': self.safe_float(ticker, 'bid'),
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': self.safe_float(ticker, 'dchange'),
            'percentage': self.safe_float(ticker, 'dchangepec'),
            'average': None,
            'baseVolume': None,
            'quoteVolume': self.safe_float(ticker, 'vol'),
            'info': ticker,
        }

    def fetch_ohlcv(self, symbol, timeframe='1d', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        response = self.publicGetGETV1ApiKline(self.extend({
            'pair': market['id'],
            'type': self.timeframes[timeframe],
        }, params))
        ohlcvs = response['data']
        return self.parse_ohlcvs(ohlcvs, market, timeframe, since, limit)

    def parse_trade(self, trade, market):
        side_flag = 'sell'
        price = float(trade[1])
        if price > 0.00000000000000000001:
            side_flag = 'buy'
        timestamp = trade[3]
        fee_num = None
        if len(trade) >= 7:
            fee_num = float(trade[6])

        return {
            'id': trade[0],
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': trade[5],
            'order': None,
            'type': trade[4],
            'side': side_flag,
            'price': price,
            'amount': float(trade[2]),
            'fee': fee_num,
        }

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        response = self.publicGetGETV1ApiTrades(self.extend({
            'pair': market['id'],
        }, params))
        trades = response['data']
        newTrades = []
        for i in range(0, len(trades)):
            oneTrade = []
            for k in range(0, len(trades[i])):
                oneTrade.append(trades[i][k])
            oneTrade.append(symbol)
            newTrades.append(oneTrade)

        return self.parse_trades(newTrades, market, since, limit)

    def fetch_my_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        response = self.privatePostPOSTV1ApiTrades(params)
        trades = response['data']
        newTrades = []
        for i in range(0, len(trades)):
            oneTrade = []
            oneTrade.append(trades[i][0])
            oneTrade.append(trades[i][3])
            oneTrade.append(trades[i][4])
            oneTrade.append(trades[i][2])
            oneTrade.append(trades[i][6])
            oneTrade.append(trades[i][1])
            oneTrade.append(trades[i][8])
            newTrades.append(oneTrade)

        return self.parse_trades(newTrades, None, since, limit)

    def parse_order_status(self, status):
        statuses = {
            '0': 'Start',
            '1': 'Partially Executed',  # partially filled
            '2': 'Executed',
            '3': 'Cancelled',
        }
        if status in statuses:
            return statuses[status]
        return status

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'order_id': id,
        }
        response = self.privateGetGETV1ApiOrderdetail(self.extend(request, params))
        order = response['data']
        timestamp = order[2]
        status = self.parse_order_status(order[9])
        side = self.safe_string(order, 'flag')
        total = float(order[4])
        completed = float(order[3])
        remain = total - completed
        sidex = 'sell'
        price = float(order[5])
        if price > 0.0000000000001:
            sidex = 'buy'
        result = {
            'info': order,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': order[1],
            'type': order[7],
            'side': sidex,
            'price': price,
            'cost': None,
            'average': order[6],
            'amount': total,
            'filled': completed,
            'remaining': remain,
            'status': status,
            'fee': None,
            'stop_price': order[8],
        }
        return result

    def parse_order(self, order, market=None):
        id = order[0]
        timestamp = order[2]
        symbol = order[1]
        filled = float(order[3])
        amount = float(order[4])
        side = 'sell'
        price = float(order[5])
        if price > 0.00000000000001:
            side = 'buy'
        remaining = amount - filled
        tradePrice = float(order[6])
        cost = filled * tradePrice
        type = order[7]
        stopPrice = float(order[8])
        status = self.parse_order_status(order[9])
        result = {
            'info': order,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': cost,
            'average': None,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': None,
            'stop_price':stopPrice,
        }
        return result

    def fetch_orders_books(self, symbol=None, params={}):
        self.load_markets()
        response = self.privatePostPOSTV1ApiOrders(params)
        if 'data' in response:
            return self.parse_orders(response['data'], None, None, None)
        return []

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        response = self.privatePostPOSTV1ApiAuthOrders()
        if 'data' in response:
            return self.parse_orders(response['data'], None, since, limit)
        return []

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        order = {
            'isbid': side,
            'order_type': type,
            'pair': self.market_id(symbol),
            'amount': amount,
        }
        if type == 'STOP-LIMIT':
            order['stop_price'] = price
        else:
            order['stop_price'] = 0
        result = self.privatePostPOSTV1ApiPlaceOrder(self.extend(order, params))
        return {
            'info': result,
            'id': result['data']['orderId'],
        }

    def cancel_order(self, id, symbol=None, params={}):
        if symbol == None:
            raise ExchangeError(self.id + ' cancelOrder() requires a symbol argument')
        self.load_markets()
        return self.privatePostPOSTV1ApiCancelOrder(self.extend({
            'order_id': id,
            'pair': self.market_id(symbol),
        }, params))

    def show_lever_orders(self, page, pagesize, params={}):
        self.load_markets()
        order = {
            'page': page,
            'pageSize': pagesize,
        }

        result = self.privatePostPOSTApiV1ShowOpenLeverOrder(self.extend(order, params))
        return {
            'info': result,
            'orders': result['data']['orders'],
        }

    def create_lever_order(self, symbol, side, amount, price, rate, params={}):
        self.load_markets()
        order = {
            'isBid': side,
            'price': price,
            'pair': self.market_id(symbol),
            'number': amount,
            'rate': rate,
        }

        result = self.privatePostPOSTApiV1MakeLeverOrder(self.extend(order, params))
        return {
            'info': result,
            'orderId': result['data']['orderId'],
        }

    def change_lever_order(self, id, params={}):
        return self.privatePostPOSTApiV1LeverageChangeOrder(self.extend({
            'orderId': id,
        }, params))


    def leverage_charge(self, id, number, params={}):
        return self.privatePostPOSTApiV1LeverageCharge(self.extend({
            'orderId': id,
            'number': number,
        }, params))

    def cancel_lever_order(self, id, params={}):
        return self.privatePostPOSTApiV1CancleLeverOrder(self.extend({
            'orderId': id,
        }, params))

    def nonce(self):
        return self.milliseconds()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        if self.id == 'cryptocapital':
            raise ExchangeError(self.id + ' is an abstract base API for xex')
        url = self.urls['api'] + '/' + path
        if api == 'public':
            if params:
                url += '?' + self.urlencode(params)
        else:
            unsigned = {}
            if 'unsigned' in params :
                unsigned = params["unsigned"]
                del params['unsigned']

            self.check_required_credentials()
            time = self.nonce()
            query = self.keysort(self.extend({
                'api_key': self.apiKey,
                'auth_nonce': time,
            }, params))
            print(query)

            temp_str = ''
            for key in query:
            	temp_str += str(query[key])

            signed = self.hash(self.encode(temp_str + self.secret))
            if method == 'GET':
                signed = self.hash(self.encode(self.apiKey + str(time) + self.secret))
            
            if not unsigned:
            	query = self.extend(query, unsigned)

            query_str = self.urlencode(query)
            url += '?' + query_str + '&auth_sign=' + signed;
            headers = {'Content-Type': 'application/json'}
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def request(self, path, api='public', method='GET', params={}, headers=None, body=None):
        response = self.fetch2(path, api, method, params, headers, body)
        if 'msg' in response:
            errors = response['msg']
            raise ExchangeError(self.id + ' ' + errors)
        return response
